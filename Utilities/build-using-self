#!/usr/bin/env python3
# ===----------------------------------------------------------------------===##
#
# This source file is part of the Swift open source project
#
# Copyright (c) 2025 Apple Inc. and the Swift project authors
# Licensed under Apache License v2.0 with Runtime Library Exception
#
# See http://swift.org/LICENSE.txt for license information
# See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
#
# ===----------------------------------------------------------------------===##

import argparse
import dataclasses
import itertools
import logging
import os
import pathlib
import platform
import shlex
import sys
import threading
import time
from datetime import datetime

import typing as t

from helpers import (
    Configuration,
    change_directory,
    call,
    call_output,
)

logging.basicConfig(
    format=" | ".join(
        [
            # Prefix script name to the log in an attempt to avoid confusion when parsing logs
            f"{pathlib.Path(sys.argv[0]).name}",
            "%(asctime)s",
            "%(levelname)-8s",
            "%(module)s",
            "%(funcName)s",
            "Line:%(lineno)d",
            "%(message)s",
        ]
    ),
    level=logging.INFO,
)


REPO_ROOT_PATH = pathlib.Path(__file__).parent.parent.resolve()


class UnsupportedArchitecture(Exception):

    pass


def get_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument(
        "-v",
        "--verbose",
        dest="is_verbose",
        action="store_true",
        help="When set, prints verbose information.",
    )
    parser.add_argument(
        "-c",
        "--configuration",
        type=Configuration,
        dest="config",
        default=Configuration.DEBUG,
        choices=[e for e in Configuration],
        help="The configuration to use.",
    )
    parser.add_argument(
        "-t",
        "--triple",
        type=str,
        dest="triple",
    )
    parser.add_argument(
        "-b",
        "--build-system",
        type=str,
        dest="build_system",
    )
    parser.add_argument(
        "--additional-build-args",
        type=str,
        dest="additional_build_args",
        default=""
    )
    parser.add_argument(
        "--additional-run-args",
        type=str,
        dest="additional_run_args",
        default=""
    )
    parser.add_argument(
        "--additional-test-args",
        type=str,
        dest="additional_test_args",
        default=""
    )
    parser.add_argument(
        "--skip-bootstrap",
        dest="skip_bootstrap",
        action="store_true"
    )
    parser.set_defaults(skip_bootstrap=False)
    args = parser.parse_args()
    return args


def log_environment() -> None:
    logging.info("Environment Variables")
    for key, value in sorted(os.environ.items()):
        logging.info("  --> %s=%r", key, value)


def get_swiftpm_bin_dir(config: Configuration) -> pathlib.Path:
    logging.info("Retrieving Swift PM binary directory.")
    swiftpm_bin_dir = pathlib.Path(
        call_output(["swift", "build", "--configuration", config, "--show-bin-path"])
    )
    logging.info("SwiftPM BIN DIR: %s", swiftpm_bin_dir)
    return swiftpm_bin_dir


def get_event_stream_json_path() -> t.Optional[pathlib.Path]:
    returnValue = None
    if workspace_dir := os.environ.get("WORKSPACE"):
        returnValue = pathlib.Path(f"{workspace_dir}/event-stream.json")

    logging.debug("Event stream path: %r", returnValue)
    return returnValue


def is_on_darwin() -> bool:
    return platform.system() == "Darwin"


def is_on_windows() -> bool:
    return platform.system() == "Windows"


def set_environment() -> None:
    os.environ["SWIFTCI_IS_SELF_HOSTED"] = "1"

    # Ensure SDKROOT is configure
    if is_on_darwin():
        sdk_root = call_output(shlex.split("xcrun --show-sdk-path --sdk macosx"))
        logging.debug("macos sdk root = %r", sdk_root)
        os.environ["SDKROOT"] = sdk_root
    log_environment()


def run_bootstrap(swiftpm_bin_dir: pathlib.Path) -> None:
    logging.info("Current working directory is %s", pathlib.Path.cwd())
    logging.info("Bootstrapping with the XCBuild codepath...")
    cross_compile_arch: str
    arch = platform.machine()
    if arch == "arm64":
        cross_compile_arch = "x86_64"
    elif arch == "x86_64":
        cross_compile_arch = "arm64"
    else:
        raise UnsupportedArchitecture(f"Architecture {arch} is not supported.")

    call(
        [
            REPO_ROOT_PATH / "Utilities" / "bootstrap",
            "build",
            "--release",
            "--verbose",
            "--cross-compile-hosts",
            f"macosx-{cross_compile_arch}",
            "--skip-cmake-bootstrap",
            "--swift-build-path",
            (swiftpm_bin_dir / "swift-build").resolve(),
        ],
    )


GlobalArgsValueType = str


@dataclasses.dataclass
class GlobalArgs:
    global_argument: str
    value: t.Optional[GlobalArgsValueType]


def filterIsTruthy(items: t.Iterable) -> t.Iterable:
    return list(filter(lambda x: x, items))

def enable_event_stream(path_name: t.Optional[pathlib.Path]) -> bool:
    return path_name and is_on_windows()


def stream_event_file(event_stream_path: pathlib.Path, stop_event: threading.Event) -> None:
    """Stream the contents of the event stream file as it's being written."""
    logging.info("Starting to stream event file: %s", event_stream_path)

    # Wait for the file to be created if it doesn't exist
    while not event_stream_path.exists() and not stop_event.is_set():
        time.sleep(0.1)

    if stop_event.is_set():
        return

    file_position = 0
    retry_count = 0
    max_retries = 5
    
    while not stop_event.is_set():
        try:
            # Open with UTF-8 encoding and read sharing for Windows compatibility
            with open(event_stream_path, 'r', encoding='utf-8', errors='replace') as f:
                f.seek(file_position)
                
                # Read available content
                while not stop_event.is_set():
                    line = f.readline()
                    if line:
                        print(f"[EVENT-STREAM] {line.rstrip()}")
                        file_position = f.tell()
                        retry_count = 0  # Reset on successful read
                    else:
                        # Check stop event before sleeping
                        if stop_event.wait(0.1):  # Wait 0.1s or until stop_event is set
                            break
                        break  # Exit inner loop to reopen file
                        
        except PermissionError as e:
            retry_count += 1
            if retry_count <= max_retries:
                logging.debug("Permission denied, retrying (%d/%d): %s", retry_count, max_retries, e)
                # Use wait() instead of sleep() to be responsive to stop_event
                if stop_event.wait(0.2 * retry_count):  # Exponential backoff but responsive
                    break
            else:
                logging.warning("Could not read event stream file after %d attempts: %s", max_retries, e)
                break
        except (FileNotFoundError, OSError) as e:
            logging.warning("Could not read event stream file: %s", e)
            # Use wait() instead of sleep() to be responsive to stop_event
            if stop_event.wait(0.5):
                break
        except Exception as e:
            logging.error("Error streaming event file: %s", e)
            break

    logging.info("Stopped streaming event file")


def run_test_command_with_streaming(
    test_command: t.List[str],
    event_stream_path: t.Optional[pathlib.Path]
) -> None:
    """Run the test command with optional event stream file streaming."""
    # If we have an event stream path, run the command and stream the file concurrently
    if enable_event_stream(event_stream_path):
        logging.info("Starting test execution with event streaming...")

        # Event to signal the streaming thread to stop
        stop_streaming = threading.Event()

        # Start the file streaming thread
        stream_thread = threading.Thread(
            target=stream_event_file,
            args=(pathlib.Path(event_stream_path), stop_streaming)
        )
        stream_thread.daemon = True
        stream_thread.start()

        try:
            # Run the test command
            call(test_command)
        finally:
            # Stop the streaming thread
            stop_streaming.set()
            # Give the thread a moment to finish
            stream_thread.join(timeout=1.0)
            logging.info("Test execution completed")
    else:
        # No event stream, run normally
        call(test_command)

def main() -> None:
    args = get_arguments()
    logging.getLogger().setLevel(logging.DEBUG if args.is_verbose else logging.INFO)
    logging.debug("Args: %r", args)
    ignore_args = ["-Xlinker", "/ignore:4217"] if os.name == "nt" else []
    globalArgsData = [
        GlobalArgs(global_argument="--triple", value=args.triple),
        GlobalArgs(global_argument="--build-system", value=args.build_system),
    ]
    global_args: t.Iterator[GlobalArgsValueType] = list(
        itertools.chain.from_iterable(
            [[arg.global_argument, arg.value] for arg in globalArgsData if arg.value]
        )
    )
    logging.debug("Global Args: %r", global_args)
    start_time = datetime.now()
    with change_directory(REPO_ROOT_PATH):
        swiftpm_bin_dir = get_swiftpm_bin_dir(config=args.config)
        set_environment()

        call(
            filterIsTruthy(
                [
                    "swift",
                    "--version",
                ]
            )
        )

        call(
            filterIsTruthy(
                [
                    "swift",
                    "package",
                    "update",
                ]
            )
        )
        call(
            filterIsTruthy(
                [
                    "swift",
                    "build",
                    *global_args,
                    "--configuration",
                    args.config,
                    *ignore_args,
                    *args.additional_build_args.split(" ")
                ]
            )
        )

        event_stream_json_path_name = get_event_stream_json_path()
        extraArgs = [
            "--event-stream-output-path",
            event_stream_json_path_name,
        ] if enable_event_stream(event_stream_json_path_name)  else []

        # Prepare the command
        run_test_command_with_streaming(
            filterIsTruthy(
                [
                    "swift",
                    "run",
                    *ignore_args,
                    *args.additional_run_args.split(" "),
                    "swift-test",
                    *global_args,
                    "--configuration",
                    args.config,
                    "--parallel",
                    "--scratch-path",
                    ".test",
                    *ignore_args,
                    *extraArgs,
                    *args.additional_test_args.split(" ")
                ]
            ),
            event_stream_json_path_name,
        )

    if is_on_darwin() and not args.skip_bootstrap:
        run_bootstrap(swiftpm_bin_dir=swiftpm_bin_dir)

    end_time = datetime.now()
    elapsed_time = end_time - start_time

    logging.info("Done (%s)", str(elapsed_time))


if __name__ == "__main__":
    main()
