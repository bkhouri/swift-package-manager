//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift open source project
//
// Copyright (c) 2015-2016 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Basics
import CoreCommands
import Foundation
import PackageGraph
import PackageModel
import SPMBuildCore

import enum TSCBasic.ProcessEnv
import func TSCBasic.exec

import enum TSCUtility.Diagnostics

#if canImport(Android)
import Android
#endif

/// An enumeration of the errors that can be generated by the run tool.
 enum RunError: Swift.Error {
    /// The package manifest has no executable product.
    case noExecutableFound

    /// Could not find a specific executable in the package manifest.
    case executableNotFound(String)

    /// There are multiple executables and one must be chosen.
    case multipleExecutables([String])
}

extension RunError: CustomStringConvertible {
    var description: String {
        switch self {
        case .noExecutableFound:
            return "no executable product available"
        case .executableNotFound(let executable):
            return "no executable product named '\(executable)'"
        case .multipleExecutables(let executables):
            let joinedExecutables = executables.joined(separator: ", ")
            return "multiple executable products available: \(joinedExecutables)"
        }
    }
}


/// swift-run command namespace
public struct SwiftRunCommand: AsyncSwiftCommand {
    public static var configuration = CommandConfiguration(
        commandName: "run",
        _superCommandName: "swift",
        abstract: "Build and run an executable product.",
        discussion: "SEE ALSO: swift build, swift package, swift test",
        version: SwiftVersion.current.completeDisplayString,
        helpNames: [.short, .long, .customLong("help", withSingleDash: true)])

    @OptionGroup()
    public var globalOptions: GlobalOptions

    @OptionGroup()
    var options: RunCommandOptions

    public var toolWorkspaceConfiguration: ToolWorkspaceConfiguration {
        return .init(wantsREPLProduct: options.mode == .repl)
    }

    public func run(_ swiftCommandState: SwiftCommandState) async throws {
        if self.options.shouldBuildTests && self.options.shouldSkipBuild {
            swiftCommandState.observabilityScope.emit(
              .mutuallyExclusiveArgumentsError(arguments: ["--build-tests", "--skip-build"])
            )
            throw ExitCode.failure
        }

        let runCommand = RunCommandFactory.getInstance(
            mode: options.mode,
            fileSystem: swiftCommandState.fileSystem,
            executable: self.options.executable,
        )

        do {
            try await runCommand.run(
                swiftCommandState: swiftCommandState,
                globalOptions: self.globalOptions,
                options: self.options,
            )
        } catch Diagnostics.fatalError {
            if self.options.mode != .repl {
                throw ExitCode.failure
            }
        } catch let error as RunError {
            if self.options.mode != .repl {
                swiftCommandState.observabilityScope.emit(error)
                throw ExitCode.failure
            }
        }
    }

    public init() {}
}

